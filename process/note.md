# linux系统编程——进程
## 创建进程及基本概念
僵尸进程:占用资源小，大概一个结构体大小。但是占用宝贵的进程号资源<br>
fork(): 创建一个子进程，写时拷贝技术，谁写谁拷贝
___
## 进程的消亡及释放资源
wait(int *status);   //阻塞等待<br>

waitpid(pid_t pid,int *status,int options);  //可以立即退出，作为非阻塞函数<br>

witid();
wait3();
wait4();
___
## 进程分配
将一个任务分发给多个进程实现并发，针对任务量的分配方法有：
1. 分块法
2. 交叉分配法
3. 池，将任务下发到池中，由各个进程自己去拿取处理，注意避免竞争的发生。
___
## exec函数族
replacse:你还是你，你不是你<br>

exec函数族的函数执行后，若exec调用成功，则整个进程跳转到新的代码空间执行，原代码exec函数后面的内容不再执行，只有当exec函数调用失败的时候才会执行原代码exec函数后面的内容

- execl()
- execlp()
- execle()
- execv()
- execvp()<br>
注意：使用fflush()函数来刷新缓冲区

---

# 并发
异步事件处理方式：查询法，中断处理法



## 信号
1. 信号的概念<br>
信号时软件中断。
命令 kill -l 查看信号，有标准信号(1-31)和实时信号。
当代码异常终止或者运行出错时，会产生代码出错现场记录，其文件为core.进程号，所以可以使用core文件调试代码。
命令:ulimit 设置core文件大小。

2. signal()函数<br>
signal(int sig,void(*func)(int));<br>
func 有三种取值，1. SIG_IGN:忽略该信号  2. SIG_DFL：使用系统默认操作  3. 自定义响应函数指针<br>
特别注意：**信号会打断阻塞的系统调用**


3. 信号的不可靠<br>
信号的行为不可靠。

4. 可重入函数<br>
解决信号的行为不可靠。（第一次调用没有结束就发生第二次信号处理函数调用）<br>
可重入函数：第一次调用没有结束可处理第二次调用。<br>
所有的系统调用都是可重入的，一部分库函数也是可以重入的，如：memcpy


5. 信号的响应过程<br>
标准信号的响应没有严格的顺序。


6. 信号常用函数:kill(),raise(),alarm(),pause(),system(),sleep()<br>

7. 信号集<br>

8. 信号屏蔽字/pending集的处理<br>
扩展：sigsuepend(),sigaction(),setitimer()<br>
实时信号<br>

## 线程